import { ThinSprite } from "@babylonjs/core/Sprites/thinSprite.js";
import { SpriteNode } from "../sprites/spriteNode.js";
import { BezierCurve } from "../maths/bezier.js";
import { Node } from "../rendering/node.js";
import { ControlNode } from "../rendering/controlNode.js";
/**
 * Default scale value for the scale property of a Lottie transform.
 */
const DefaultScale = { x: 1, y: 1 };
/**
 * Default position value for the position property of a Lottie transform.
 */
const DefaultPosition = { x: 0, y: 0 };
/**
 * Parses a lottie animation file and converts it into a format that can be rendered by Babylon.js
 * Important: not all lottie features are supported, you can call .debug() after parsing an animation to see what features were not supported.
 */
export class AnimationParser {
    /**
     * Get the animation information parsed from the Lottie file.
     */
    get animationInfo() {
        return this._animationInfo;
    }
    /**
     * Creates a new instance of the Lottie animations parser.
     * @param packer Object that packs the sprites from the animation into a texture atlas.
     * @param fileContentAsJsonString The content of the lottie file as a JSON string.
     * @param configuration Configuration options for the animation parser.
     * @param renderingManager Object that manages the rendering of the sprites in the animation.
     */
    constructor(packer, fileContentAsJsonString, configuration, renderingManager) {
        // Loop variables to save allocations
        this._shape = undefined;
        this._packer = packer;
        this._renderingManager = renderingManager;
        this._configuration = configuration;
        this._unsupportedFeatures = [];
        this._parentNodes = new Map();
        this._rootNodes = [];
        this._animationInfo = this._loadFromData(fileContentAsJsonString);
    }
    /**
     * Logs to the console all issues that were encountered during parsing the file.
     */
    debug() {
        for (let i = 0; i < this._unsupportedFeatures.length; i++) {
            // eslint-disable-next-line no-console
            console.log(this._unsupportedFeatures[i]);
        }
    }
    _loadFromData(fileContentAsJsonString) {
        this._unsupportedFeatures.length = 0; // Clear previous errors
        const rawData = JSON.parse(fileContentAsJsonString);
        for (let i = 0; i < rawData.layers.length; i++) {
            this._parseLayer(rawData.layers[i]);
        }
        // Update the atlas texture after creating all sprites from the animation
        this._packer.updateAtlasTexture();
        // Reorder the sprites from back to front
        this._renderingManager.ready();
        // Release the canvas to avoid memory leaks
        this._packer.releaseCanvas();
        this._packer = undefined; // Clear the reference to the sprite packer to allow garbage collection
        return {
            startFrame: rawData.ip,
            endFrame: rawData.op,
            frameRate: rawData.fr,
            widthPx: rawData.w,
            heightPx: rawData.h,
            nodes: this._rootNodes,
        };
    }
    _parseLayer(layer) {
        if (layer.hd === true) {
            return; // Ignore hidden layers
        }
        if (layer.ty !== 3 && layer.ty !== 4) {
            this._unsupportedFeatures.push(`UnsupportedLayerType - Index: ${layer.ind} Name: ${layer.nm} Type: ${layer.ty}`);
            return;
        }
        if (layer.ind === undefined || layer.ip === undefined || layer.op === undefined || layer.st === undefined) {
            this._unsupportedFeatures.push(`Layer without required values - Name: ${layer.nm}`);
            return;
        }
        let parentNode = undefined;
        if (layer.parent) {
            parentNode = this._parentNodes.get(layer.parent);
            if (parentNode === undefined) {
                this._unsupportedFeatures.push(`Parent node with index ${layer.parent} not found for layer ${layer.nm}`);
            }
        }
        const transform = this._parseTransform(layer.ks);
        const controlNode = new ControlNode(parentNode ? `${parentNode.id} - ${layer.nm} - ControlNode (TRS)` : `${layer.nm} - ControlNode (TRS)`, this._configuration.ignoreOpacityAnimations, layer.ip, layer.op, transform.position, transform.rotation, transform.scale, transform.opacity, parentNode);
        // Nodes without a parent are top-level nodes in the scenegraph
        if (!parentNode) {
            this._rootNodes.push(controlNode);
        }
        const anchorNode = new Node(parentNode ? `${parentNode.id} - ${layer.nm} - Node (Anchor)` : `${layer.nm} - Node (Anchor)`, this._configuration.ignoreOpacityAnimations, transform.anchorPoint, undefined, // Rotation is not used for anchor point
        undefined, // Scale is not used for anchor point
        undefined, // Opacity is not used for anchor point
        controlNode);
        // Anchor nodes are always the parent of the control node of a child layer, build a map to build the scenegraph
        this._parentNodes.set(layer.ind, anchorNode);
        // Create the sprites for the layer if it has shapes
        if (layer.shapes && layer.shapes.length > 0) {
            const scalingFactor = this._getScaleFactor(anchorNode);
            this._parseShapes(anchorNode, layer.shapes, scalingFactor);
        }
    }
    _parseShapes(parent, shapes, scalingFactor) {
        for (let i = 0; i < shapes.length; i++) {
            if (shapes[i].hd === true) {
                continue; // Ignore hidden shapes
            }
            if (shapes[i].ty === "gr") {
                this._parseGroupShape(parent, shapes[i], scalingFactor);
            }
            else {
                this._unsupportedFeatures.push(`Only group shapes are supported as children of layers - Name: ${shapes[i].nm} Type: ${shapes[i].ty}`);
                continue;
            }
        }
    }
    _parseGroupShape(parent, rawGroup, scalingFactor) {
        if (!rawGroup.it || rawGroup.it.length === 0) {
            return;
        }
        let transform = undefined;
        for (let i = 0; i < rawGroup.it.length; i++) {
            this._shape = rawGroup.it[i];
            if (this._shape.ty === "gr") {
                this._unsupportedFeatures.push(`Nested group shapes are not supported. - Group ${rawGroup.nm} - Nested Group ${this._shape.nm}`);
            }
            else if (this._shape.ty === "tr") {
                transform = this._parseTransform(this._shape);
            }
            else if (this._shape.ty === "sh") {
                this._validatePathShape(this._shape);
            }
            else if (this._shape.ty === "rc") {
                this._validateRectangleShape(this._shape);
            }
            else if (this._shape.ty === "fl") {
                this._validateFillShape(this._shape);
            }
            else if (this._shape.ty === "gf") {
                this._validateGradientFillShape(this._shape);
            }
            else {
                this._unsupportedFeatures.push(`Unsupported shape type - Name: ${this._shape.nm} Type: ${this._shape.ty}`);
            }
        }
        if (transform === undefined) {
            this._unsupportedFeatures.push(`Group ${rawGroup.nm} does not have a transform which is not supported`);
            return;
        }
        const trsNode = new Node(`${parent.id} - ${rawGroup.nm} - ControlNode (TRS)`, this._configuration.ignoreOpacityAnimations, transform.position, transform.rotation, transform.scale, transform.opacity, parent);
        const spriteInfo = this._packer.addLottieShape(rawGroup, scalingFactor);
        const sprite = new ThinSprite();
        // Set sprite UV coordinates
        sprite._xOffset = spriteInfo.uOffset;
        sprite._yOffset = spriteInfo.vOffset;
        sprite._xSize = spriteInfo.cellWidth;
        sprite._ySize = spriteInfo.cellHeight;
        // Set sprite dimensions for rendering
        sprite.width = spriteInfo.widthPx;
        sprite.height = spriteInfo.heightPx;
        sprite.invertV = true;
        this._renderingManager.addSprite(sprite);
        transform.anchorPoint.startValue.x += spriteInfo.centerX || 0;
        transform.anchorPoint.startValue.y -= spriteInfo.centerY || 0;
        new SpriteNode(`${parent.id} - ${rawGroup.nm} - SpriteNode (Anchor)`, this._configuration.ignoreOpacityAnimations, sprite, transform.anchorPoint, undefined, // Rotation is not used for anchor point
        undefined, // Scale is not used for anchor point
        undefined, // Opacity is not used for anchor point
        trsNode);
    }
    _parseTransform(transform) {
        return {
            opacity: this._fromLottieScalarToBabylonScalar(transform.o, "Opacity", 1),
            rotation: this._fromLottieScalarToBabylonScalar(transform.r, "Rotation", 0),
            scale: this._fromLottieVector2ToBabylonVector2(transform.s, "Scale", DefaultScale),
            position: this._fromLottieVector2ToBabylonVector2(transform.p, "Position", DefaultPosition),
            anchorPoint: this._fromLottieVector2ToBabylonVector2(transform.a, "AnchorPoint", DefaultPosition),
        };
    }
    _fromLottieScalarToBabylonScalar(property, scalarType, defaultValue) {
        if (!property) {
            return {
                startValue: defaultValue,
                currentValue: defaultValue,
                currentKeyframeIndex: 0,
            };
        }
        if (property.a === 0) {
            return {
                startValue: property.k,
                currentValue: property.k,
                currentKeyframeIndex: 0,
            };
        }
        const keyframes = [];
        const rawKeyFrames = property.k;
        let i = 0;
        for (i = 0; i < rawKeyFrames.length; i++) {
            let easeFunction = undefined;
            if (rawKeyFrames[i].o !== undefined && rawKeyFrames[i].i !== undefined) {
                if (Array.isArray(rawKeyFrames[i].o.x)) {
                    // Value is an array
                    easeFunction = new BezierCurve(rawKeyFrames[i].o.x[0], rawKeyFrames[i].o.y[0], rawKeyFrames[i].i.x[0], rawKeyFrames[i].i.y[0], this._configuration.easingSteps);
                }
                else {
                    // Value is a number
                    easeFunction = new BezierCurve(rawKeyFrames[i].o.x, rawKeyFrames[i].o.y, rawKeyFrames[i].i.x, rawKeyFrames[i].i.y, this._configuration.easingSteps);
                }
            }
            let value = rawKeyFrames[i].s[0];
            if (scalarType === "Rotation") {
                value = (value * Math.PI) / 180; // Lottie uses degrees for rotation, convert to radians
            }
            keyframes.push({
                value: value,
                time: rawKeyFrames[i].t,
                easeFunction: easeFunction, // We assume that the ease function is always defined if we have keyframes
            });
        }
        let startValue = rawKeyFrames[0].s[0];
        if (scalarType === "Rotation") {
            startValue = (startValue * Math.PI) / 180; // Lottie uses degrees for rotation, convert to radians
        }
        return {
            startValue: startValue,
            currentValue: startValue,
            keyframes: keyframes,
            currentKeyframeIndex: 0,
        };
    }
    _fromLottieVector2ToBabylonVector2(property, vectorType, defaultValue) {
        if (!property) {
            return {
                startValue: defaultValue,
                currentValue: defaultValue,
                currentKeyframeIndex: 0,
            };
        }
        if (property.l !== undefined && property.l !== 2) {
            this._unsupportedFeatures.push(`Invalid Vector2 Length - Length: ${property.l}`);
            return {
                startValue: defaultValue,
                currentValue: defaultValue,
                currentKeyframeIndex: 0,
            };
        }
        if (property.a === 0) {
            const values = property.k;
            const value = this._calculateFinalVector(values[0], values[1], vectorType);
            return {
                startValue: value,
                currentValue: value,
                currentKeyframeIndex: 0,
            };
        }
        const keyframes = [];
        const rawKeyFrames = property.k;
        let i = 0;
        for (i = 0; i < rawKeyFrames.length; i++) {
            let easeFunction1 = undefined;
            if (rawKeyFrames[i].o !== undefined && rawKeyFrames[i].i !== undefined) {
                if (Array.isArray(rawKeyFrames[i].o.x)) {
                    // Value is an array
                    easeFunction1 = new BezierCurve(rawKeyFrames[i].o.x[0], rawKeyFrames[i].o.y[0], rawKeyFrames[i].i.x[0], rawKeyFrames[i].i.y[0], this._configuration.easingSteps);
                }
                else {
                    // Value is a number
                    easeFunction1 = new BezierCurve(rawKeyFrames[i].o.x, rawKeyFrames[i].o.y, rawKeyFrames[i].i.x, rawKeyFrames[i].i.y, this._configuration.easingSteps);
                }
            }
            let easeFunction2 = undefined;
            if (rawKeyFrames[i].o !== undefined && rawKeyFrames[i].i !== undefined) {
                if (Array.isArray(rawKeyFrames[i].o.x)) {
                    // Value is an array
                    easeFunction2 = new BezierCurve(rawKeyFrames[i].o.x[1], rawKeyFrames[i].o.y[1], rawKeyFrames[i].i.x[1], rawKeyFrames[i].i.y[1], this._configuration.easingSteps);
                }
                else {
                    // Value is a number
                    easeFunction2 = new BezierCurve(rawKeyFrames[i].o.x, rawKeyFrames[i].o.y, rawKeyFrames[i].i.x, rawKeyFrames[i].i.y, this._configuration.easingSteps);
                }
            }
            keyframes.push({
                value: this._calculateFinalVector(rawKeyFrames[i].s[0], rawKeyFrames[i].s[1], vectorType),
                time: rawKeyFrames[i].t,
                easeFunction1: easeFunction1, // We assume that the ease function is always defined if we have keyframes
                easeFunction2: easeFunction2, // We assume that the ease function is always defined if we have keyframes
            });
        }
        const startValue = this._calculateFinalVector(rawKeyFrames[0].s[0], rawKeyFrames[0].s[1], vectorType);
        return {
            startValue: startValue,
            currentValue: { x: startValue.x, y: startValue.y }, // All vectors are passed by reference, so we need to create a copy to avoid modifying the start value
            keyframes: keyframes,
            currentKeyframeIndex: 0,
        };
    }
    _calculateFinalVector(x, y, vectorType) {
        const result = { x, y };
        if (vectorType === "Position") {
            // Lottie uses a different coordinate system for position, so we need to invert the Y value
            result.y = -result.y;
        }
        else if (vectorType === "AnchorPoint") {
            // Lottie uses a different coordinate system for anchor point, so we need to invert the X value
            result.x = -result.x;
        }
        else if (vectorType === "Scale") {
            // Lottie uses a different coordinate system for scale, so we need to divide by 100
            result.x = result.x / 100;
            result.y = result.y / 100;
        }
        return result;
    }
    _getScaleFactor(node) {
        const scale = { x: node.startScale.x, y: node.startScale.y };
        while (node.parent) {
            node = node.parent;
            scale.x *= node.startScale.x;
            scale.y *= node.startScale.y;
        }
        scale.x = scale.x * this._configuration.scaleMultiplier;
        scale.y = scale.y * this._configuration.scaleMultiplier;
        return scale;
    }
    _validatePathShape(shape) {
        if (shape.ks.a === 1) {
            this._unsupportedFeatures.push(`Path ${shape.nm} has animated properties which are not supported`);
        }
    }
    _validateRectangleShape(shape) {
        if (shape.p.a === 1) {
            this._unsupportedFeatures.push(`Rectangle ${shape.nm} has an position property that is animated which is not supported`);
        }
        if (shape.s.a === 1) {
            this._unsupportedFeatures.push(`Rectangle ${shape.nm} has a size property that is animated which is not supported`);
        }
        if (shape.r.a === 1) {
            this._unsupportedFeatures.push(`Rectangle ${shape.nm} has a rounded corners property that is animated which is not supported`);
        }
    }
    _validateFillShape(shape) {
        if (shape.o.a === 1) {
            this._unsupportedFeatures.push(`Fill ${shape.nm} has an opacity property that is animated which is not supported`);
        }
        if (shape.c.a === 1) {
            this._unsupportedFeatures.push(`Fill ${shape.nm} has a color property that is animated which is not supported`);
        }
    }
    _validateGradientFillShape(shape) {
        if (shape.o.a === 1) {
            this._unsupportedFeatures.push(`Gradient fill ${shape.nm} has an opacity property that is animated which is not supported`);
        }
        if (shape.s.a === 1) {
            this._unsupportedFeatures.push(`Gradient fill ${shape.nm} has a start point property that is animated which is not supported`);
        }
        if (shape.e.a === 1) {
            this._unsupportedFeatures.push(`Gradient fill ${shape.nm} has an end point property that is animated which is not supported`);
        }
    }
}
//# sourceMappingURL=animationParser.js.map