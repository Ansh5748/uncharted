{"version":3,"file":"rawTypes.js","sourceRoot":"","sources":["../../../../../dev/addons/src/lottie/lottie/rawTypes.ts"],"names":[],"mappings":"AAAA,wCAAwC;AACxC,sDAAsD","sourcesContent":["/* eslint-disable jsdoc/require-jsdoc */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n// Types for the raw Lottie .json data\r\n\r\n// General animation data\r\nexport type RawLottieAnimation = {\r\n    v: string; // Version\r\n    fr: number; // Framerate in frames per second\r\n    ip: number; // \tFrame the animation starts at (usually 0)\r\n    op: number; // \tFrame the animation stops/loops at, which makes this the duration in frames when ip is 0\r\n    w: number; // Width\r\n    h: number; // Height\r\n    nm?: string; // Human readable name\r\n    layers: RawLottieLayer[]; // Layers\r\n};\r\n\r\n// Layer data\r\nexport type RawLottieLayer = {\r\n    ind?: number; // Index that can be used for parenting and referenced in expressions\r\n    ty: RawLayerType; // Layer type (0: precomp, 1: solid, 2: image, 3: null, 4: shape, 5: text)\r\n    nm?: string; // Human readable name\r\n    parent?: number; // Must be the ind property of another layer\r\n    hd?: boolean; // Hidden\r\n    sr?: number; // Time Stretch\r\n    ao?: number; // Auto-Orient (0: false, 1: true), if 1, the layer will rotate itself to match its animated position path\r\n    ip?: number; // Frame when the layer becomes visible\r\n    op?: number; // Frame when the layer becomes invisible\r\n    st?: number; // Start time\r\n    ct?: number; // Collapse Transform (0: false, 1: true), marks that transforms should be applied before masks\r\n    ks: RawTransform; // Layer transform\r\n    shapes?: RawGraphicElement[];\r\n};\r\n\r\nexport type RawGraphicElement = {\r\n    nm?: string; // Human readable name\r\n    hd?: boolean; // Hidden\r\n    ty: RawShapeType; // Type ('gr' for group, 'rc' for rectangle, 'el' for ellipse, 'sh' for path, etc.)\r\n    bm?: number; // Blend mode\r\n    ix?: number; // Index\r\n};\r\n\r\nexport type RawGroupShape = RawGraphicElement & {\r\n    it?: RawGraphicElement[]; // shapes\r\n};\r\n\r\nexport type RawRectangleShape = RawGraphicElement & {\r\n    d: RawShapeDirection; // direction the shape is drawn as, mostly relevant when using trim path\r\n    p: RawPositionProperty; // center of the rectangle\r\n    s: RawVectorProperty; // size of the rectangle\r\n    r: RawScalarProperty; // rounded corners radius\r\n};\r\n\r\nexport type RawPathShape = RawGraphicElement & {\r\n    d: RawShapeDirection; // direction the shape is drawn as, mostly relevant when using trim path\r\n    ks: RawBezierShapeProperty; // bezier path\r\n};\r\n\r\nexport type RawFillShape = RawGraphicElement & {\r\n    o: RawScalarProperty; // Opacity, 100 means fully opaque\r\n    c: RawColorProperty; // Color\r\n    r: RawFillRule; // fill rule\r\n};\r\n\r\nexport type RawGradientFillShape = RawGraphicElement & {\r\n    o: RawScalarProperty; // Opacity, 100 means fully opaque\r\n    g: RawGradientsProperty; // Gradient colors\r\n    s: RawPositionProperty; // Starting point of the gradient\r\n    e: RawPositionProperty; // End point of the gradient\r\n    t: RawGradientType; // type of the gradient\r\n    h: RawScalarProperty; // highlight length as a percentage between s and e\r\n    a?: RawScalarProperty; // highlight angle in clockwise degrees, relative to the direction from s to e\r\n    r: RawFillRule; // fill rule\r\n};\r\n\r\nexport type RawTransformShape = RawGraphicElement & {\r\n    a: RawPositionProperty; // anchor point\r\n    p: RawPositionProperty; // position/translation\r\n    r: RawScalarProperty; // rotation in degrees, clockwise\r\n    s: RawVectorProperty; // scale factor, [100, 100] for no scaling\r\n    o: RawScalarProperty; // opacity\r\n    sk: RawScalarProperty; // skew amount as an angle in degrees\r\n    sa: RawScalarProperty; // skew axis, direction along which skew is applied, in degrees (0 skes along the x axis, 90 along the Y axys)\r\n};\r\n\r\nexport type RawTransform = {\r\n    a?: RawPositionProperty; // Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)\r\n    p?: RawPositionProperty; // Position / Translation\r\n    r?: RawScalarProperty; // Rotation in degrees, clockwise\r\n    s?: RawVectorProperty; // Scale factor, [100, 100] for no scaling\r\n    o?: RawScalarProperty; // Opacity\r\n};\r\n\r\nexport type RawScalarProperty = {\r\n    a: RawNumberBoolean; // Animated (0: false, 1: true)\r\n    k: number | RawVectorKeyframe[]; // When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes.\r\n};\r\n\r\nexport type RawVectorProperty = {\r\n    a: RawNumberBoolean; // Animated (0: false, 1: true)\r\n    k: number[] | RawVectorKeyframe[]; // When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes.\r\n    l: number; // Number of components in the value arrays. If present values will be truncated or expanded to match this length when accessed from expressions\r\n};\r\n\r\nexport type RawVectorKeyframe = {\r\n    t: number; // Time, Frame number\r\n    s: number[]; // Value at this keyframe\r\n    h?: RawNumberBoolean; // Hold flag (0: false, 1: true)\r\n    i?: RawKeyFrameEasing; // In tangent, easing tangent going into the next keyframe\r\n    o?: RawKeyFrameEasing; // Out tanget, easing tangent leaving the current keyframe\r\n};\r\n\r\nexport type RawPositionProperty = {\r\n    a: RawNumberBoolean; // Animated (0: false, 1: true)\r\n    k: number[] | RawPositionKeyframe[]; // When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes.\r\n    l: number; // Number of components in the value arrays. If present values will be truncated or expanded to match this length when accessed from expressions\r\n};\r\n\r\nexport type RawPositionKeyframe = {\r\n    t: number; // Time, Frame number\r\n    h?: RawNumberBoolean; // Hold flag (0: false, 1: true)\r\n    i?: RawKeyFrameEasing; // In tangent, easing tangent going into the next keyframe\r\n    o?: RawKeyFrameEasing; // Out tanget, easing tangent leaving the current keyframe\r\n    s: number[]; // Value at this keyframe\r\n    ti: number[]; // Value In Tangent, tangent for values (eg: moving position around a curved path)\r\n    to: number[]; // Value Out Tangent, tangent for values (eg: moving position around a curved path)\r\n};\r\n\r\nexport type RawBezierShapeProperty = {\r\n    a: RawNumberBoolean; // Animated (0: false, 1: true)\r\n    k: RawBezier | RawBezierShapeKeyframe[]; // When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes\r\n};\r\n\r\nexport type RawBezierShapeKeyframe = {\r\n    t: number; // Time, Frame number\r\n    h?: RawNumberBoolean; // Hold flag (0: false, 1: true)\r\n    i?: RawKeyFrameEasing; // In tangent, easing tangent going into the next keyframe\r\n    o?: RawKeyFrameEasing; // Out tanget, easing tangent leaving the current keyframe\r\n    s: RawBezier[]; // Value at this keyframe\r\n};\r\n\r\nexport type RawColorProperty = {\r\n    a: RawNumberBoolean; // Animated (0: false, 1: true)\r\n    k: number[] | RawColorKeyframe[]; // When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes\r\n};\r\n\r\nexport type RawColorKeyframe = {\r\n    t: number; // Time, Frame number\r\n    h?: RawNumberBoolean; // Hold flag (0: false, 1: true)\r\n    i?: RawKeyFrameEasing; // In tangent, easing tangent going into the next keyframe\r\n    o?: RawKeyFrameEasing; // Out tanget, easing tangent leaving the current keyframe\r\n    s: number[]; // Value at this keyframe\r\n};\r\n\r\nexport type RawGradientsProperty = {\r\n    p: number; // Color stop count\r\n    k: RawGradientProperty;\r\n};\r\n\r\nexport type RawGradientProperty = {\r\n    a: RawNumberBoolean; // Animated (0: false, 1: true)\r\n    k: number[]; // Gradient colors array\r\n};\r\n\r\nexport type RawKeyFrameEasing = {\r\n    x: number | number[]; // Time component: 0 means start time of the keyframe, 1 means time of the next keyframe.\r\n    y: number | number[]; // Value interpolation component: 0 means start value of the keyframe, 1 means value at the next keyframe.\r\n};\r\n\r\nexport type RawBezier = {\r\n    c: boolean; // Closed\r\n    i: number[][]; // In tangents, array of points, each point is an array of coordinates. These points are along the in tangents relative to the corresponding v\r\n    o: number[][]; // Out tangents, array of points, each point is an array of coordinates. These points are along the out tangents relative to the corresponding v\r\n    v: number[][]; // Vertices, array of points, each point is an array of coordinates. These points are along the bezier path\r\n};\r\n\r\nexport type RawNumberBoolean = 0 | 1; // 0: false, 1: true;\r\nexport type RawLayerType = 0 | 1 | 2 | 3 | 4 | 5 | 6; // Layer type (0: precomposition, 1: solid, 2: image, 3: null, 4: shape, 5: text, 6: audio)\r\nexport type RawShapeType = \"fl\" | \"gf\" | \"gr\" | \"tr\" | \"sh\" | \"rc\"; // Shape type (fl: fill, gf: gradient fill, gr: group, tr: transform, sh: path, rc: rectangle)\r\nexport type RawShapeDirection = 1 | 3; // 1: clockwise, 3: counter-clockwise\r\nexport type RawFillRule = 1 | 2; // Fill rule (1: non-zero, everything is colored (You can think of this as an OR), 2: even-odd, colored based on intersections and path direction, can be used to create \"holes\")\r\nexport type RawGradientType = 1 | 2; // Gradient type (1: linear, 2: radial)\r\n"]}