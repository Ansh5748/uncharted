import "@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js";
import { ThinTexture } from "@babylonjs/core/Materials/Textures/thinTexture.js";
import { GetBoundingBox } from "../maths/boundingBox.js";
/**
 * SpritePacker is a class that handles the packing of sprites into a texture atlas.
 */
export class SpritePacker {
    /**
     * Gets the texture atlas that contains all the sprites packed by this SpritePacker.
     * @returns The texture atlas containing the sprites.
     */
    get texture() {
        return this._spritesTexture;
    }
    /**
     * Creates a new instance of SpritePacker.
     * @param engine Engine that will render the sprites.
     * @param configuration Configuration options for the sprite packer.
     */
    constructor(engine, configuration) {
        this._engine = engine;
        this._configuration = configuration;
        this._isDirty = false;
        this._currentX = 0;
        this._currentY = 0;
        this._maxRowHeight = 0;
        this._spritesCanvas = new OffscreenCanvas(this._configuration.spriteAtlasSize, this._configuration.spriteAtlasSize);
        this._spritesCanvasContext = this._spritesCanvas.getContext("2d");
        this._spritesInternalTexture = this._engine.createDynamicTexture(this._configuration.spriteAtlasSize, this._configuration.spriteAtlasSize, false, 2); // Linear filtering
        this._engine.updateDynamicTexture(this._spritesInternalTexture, this._spritesCanvas, false);
        this._spritesTexture = new ThinTexture(this._spritesInternalTexture);
        this._spritesTexture.wrapU = 0; // Disable wrapping
        this._spritesTexture.wrapV = 0; // Disable wrapping
        this._spriteAtlasInfo = {
            uOffset: 0,
            vOffset: 0,
            cellWidth: 0,
            cellHeight: 0,
            widthPx: 0,
            heightPx: 0,
            centerX: 0,
            centerY: 0,
        };
    }
    /**
     * Adds a vector shape that comes from lottie data to the sprite atlas.
     * @param rawGroup The raw group shape to add to the atlas.
     * @param scalingFactor The scaling factor to apply to the shape.
     * @returns The information on how to find the sprite in the atlas.
     */
    addLottieShape(rawGroup, scalingFactor) {
        const boundingBox = GetBoundingBox(rawGroup);
        this._spriteAtlasInfo.cellWidth = boundingBox.width * scalingFactor.x;
        this._spriteAtlasInfo.cellHeight = boundingBox.height * scalingFactor.y;
        this._spriteAtlasInfo.centerX = boundingBox.centerX;
        this._spriteAtlasInfo.centerY = boundingBox.centerY;
        // Check if the sprite fits in the current row
        if (this._currentX + this._spriteAtlasInfo.cellWidth > this._configuration.spriteAtlasSize) {
            this._currentX = 0;
            this._currentY += this._maxRowHeight + this._configuration.gapSize; // Add a gap between sprites to avoid bleeding
            this._maxRowHeight = 0;
        }
        // Normalize the x/y offsets in texture coordinates (0 to 1)
        this._spriteAtlasInfo.uOffset = this._currentX / this._configuration.spriteAtlasSize;
        this._spriteAtlasInfo.vOffset = this._currentY / this._configuration.spriteAtlasSize;
        this._drawVectorShape(rawGroup, boundingBox, scalingFactor);
        this._currentX += this._spriteAtlasInfo.cellWidth + this._configuration.gapSize; // Add a gap between sprites to avoid bleeding
        this._maxRowHeight = Math.max(this._maxRowHeight, this._spriteAtlasInfo.cellHeight);
        this._spriteAtlasInfo.widthPx = boundingBox.width;
        this._spriteAtlasInfo.heightPx = boundingBox.height;
        this._isDirty = true;
        return this._spriteAtlasInfo;
    }
    /**
     * Updates the internal atlas texture with the information that has been added to the SpritePacker.
     */
    updateAtlasTexture() {
        if (!this._isDirty) {
            return; // No need to update if nothing has changed
        }
        // Update the internal texture with the new canvas content
        this._engine.updateDynamicTexture(this._spritesInternalTexture, this._spritesCanvas, false);
        this._isDirty = false;
    }
    /**
     * Releases the canvas and its context to allow garbage collection.
     */
    releaseCanvas() {
        this._spritesCanvasContext = undefined; // Clear the context to allow garbage collection
        this._spritesCanvas = undefined; // Clear the canvas to allow garbage collection
    }
    _drawVectorShape(rawGroup, boundingBox, scalingFactor) {
        this._spritesCanvasContext.save();
        this._spritesCanvasContext.translate(this._currentX, this._currentY);
        this._spritesCanvasContext.scale(scalingFactor.x, scalingFactor.y);
        this._spritesCanvasContext.beginPath();
        if (rawGroup.it) {
            for (let i = 0; i < rawGroup.it.length; i++) {
                const shape = rawGroup.it[i];
                switch (shape.ty) {
                    case "rc":
                        this._drawRectangle(shape);
                        break;
                    case "sh":
                        this._drawPath(shape, boundingBox);
                        break;
                    case "fl":
                        this._drawFill(shape);
                        break;
                    case "gf":
                        this._drawGradientFill(shape, boundingBox);
                        break;
                    default:
                        break;
                }
            }
        }
        this._spritesCanvasContext.restore();
    }
    _drawRectangle(shape) {
        const size = shape.s.k;
        const radius = shape.r.k;
        if (radius <= 0) {
            this._spritesCanvasContext.rect(0, 0, size[0], size[1]);
        }
        else {
            this._spritesCanvasContext.roundRect(0, 0, size[0], size[1], radius);
        }
    }
    _drawPath(shape, boundingBox) {
        const pathData = shape.ks.k;
        const xTranslate = boundingBox.width / 2 - boundingBox.centerX;
        const yTranslate = boundingBox.height / 2 - boundingBox.centerY;
        const vertices = pathData.v;
        const inTangents = pathData.i;
        const outTangents = pathData.o;
        if (vertices.length > 0) {
            this._spritesCanvasContext.moveTo(vertices[0][0] + xTranslate, vertices[0][1] + yTranslate);
            for (let i = 0; i < vertices.length - 1; i++) {
                const start = vertices[i];
                const end = vertices[i + 1];
                const outTangent = outTangents[i];
                const inTangent = inTangents[i + 1];
                this._spritesCanvasContext.bezierCurveTo(start[0] + xTranslate + outTangent[0], start[1] + yTranslate + outTangent[1], end[0] + xTranslate + inTangent[0], end[1] + yTranslate + inTangent[1], end[0] + xTranslate, end[1] + yTranslate);
            }
            if (pathData.c) {
                // Close path with curve from last to first point
                const start = vertices[vertices.length - 1];
                const end = vertices[0];
                const outTangent = outTangents[vertices.length - 1];
                const inTangent = inTangents[0];
                this._spritesCanvasContext.bezierCurveTo(start[0] + xTranslate + outTangent[0], start[1] + yTranslate + outTangent[1], end[0] + xTranslate + inTangent[0], end[1] + yTranslate + inTangent[1], end[0] + xTranslate, end[1] + yTranslate);
                this._spritesCanvasContext.closePath();
            }
        }
    }
    _drawFill(fill) {
        const color = this._lottieColorToCSSColor(fill.c.k, fill.o.k / 100);
        this._spritesCanvasContext.fillStyle = color;
        this._spritesCanvasContext.fill();
    }
    _drawGradientFill(fill, boundingBox) {
        switch (fill.t) {
            case 1: {
                this._drawLinearGradientFill(fill, boundingBox);
                break;
            }
            case 2: {
                this._drawRadialGradientFill(fill, boundingBox);
                break;
            }
        }
    }
    _drawLinearGradientFill(fill, boundingBox) {
        const xTranslate = boundingBox.width / 2 - boundingBox.centerX;
        const yTranslate = boundingBox.height / 2 - boundingBox.centerY;
        // Create the gradient
        const startPoint = fill.s.k;
        const endPoint = fill.e.k;
        const gradient = this._spritesCanvasContext.createLinearGradient(startPoint[0] + xTranslate, startPoint[1] + yTranslate, endPoint[0] + xTranslate, endPoint[1] + yTranslate);
        this._addColorStops(gradient, fill);
        this._spritesCanvasContext.fillStyle = gradient;
        this._spritesCanvasContext.fill();
    }
    _drawRadialGradientFill(fill, boundingBox) {
        const xTranslate = boundingBox.width / 2 - boundingBox.centerX;
        const yTranslate = boundingBox.height / 2 - boundingBox.centerY;
        // Create the gradient
        const startPoint = fill.s.k;
        const endPoint = fill.e.k;
        const gradient = this._spritesCanvasContext.createRadialGradient(startPoint[0] + xTranslate, startPoint[1] + yTranslate, 0, endPoint[0] + xTranslate, endPoint[1] + yTranslate, Math.hypot(endPoint[0] - startPoint[0], endPoint[1] - startPoint[1]) // End radius
        );
        this._addColorStops(gradient, fill);
        this._spritesCanvasContext.fillStyle = gradient;
        this._spritesCanvasContext.fill();
    }
    _addColorStops(gradient, fill) {
        const stops = fill.g.p;
        const rawColors = fill.g.k.k;
        let stopsData = undefined;
        if (rawColors.length / stops === 4) {
            stopsData = this._gradientColorsToCssColor(rawColors, stops, false);
        }
        else if (rawColors.length / stops === 6) {
            stopsData = this._gradientColorsToCssColor(rawColors, stops, true);
        }
        else {
            return;
        }
        for (let i = 0; i < stops; i++) {
            gradient.addColorStop(stopsData[i].offset, stopsData[i].color);
        }
    }
    _gradientColorsToCssColor(colors, stops, hasAlpha) {
        const skipElement = hasAlpha ? 0 : 1;
        const result = [];
        for (let i = 0; i < stops; i++) {
            const index = i * 4;
            result.push({
                offset: colors[index],
                color: this._lottieColorToCSSColor(colors.slice(index + skipElement, index + 4), 1),
            });
        }
        return result;
    }
    _lottieColorToCSSColor(color, opacity) {
        if (color.length !== 3 && color.length !== 4) {
            return "rgba(0, 0, 0, 1)"; // Default to black if invalid
        }
        const r = Math.round(color[0] * 255);
        const g = Math.round(color[1] * 255);
        const b = Math.round(color[2] * 255);
        const a = (color[3] || 1) * opacity;
        return `rgba(${r}, ${g}, ${b}, ${a})`;
    }
}
//# sourceMappingURL=spritePacker.js.map