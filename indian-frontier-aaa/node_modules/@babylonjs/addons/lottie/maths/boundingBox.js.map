{"version":3,"file":"boundingBox.js","sourceRoot":"","sources":["../../../../../dev/addons/src/lottie/maths/boundingBox.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RawBezier, RawGroupShape, RawPathShape, RawRectangleShape } from \"../lottie/rawTypes\";\r\n\r\n/**\r\n * Represents a bounding box for a shape in the animation.\r\n */\r\nexport type BoundingBox = {\r\n    /**\r\n     * Height of the bounding box\r\n     */\r\n    height: number;\r\n    /**\r\n     * Width of the bounding box\r\n     */\r\n    width: number;\r\n    /**\r\n     * X coordinate of the center of the bounding box\r\n     */\r\n    centerX: number;\r\n    /**\r\n     * Y coordinate of the center of the bounding box\r\n     */\r\n    centerY: number;\r\n};\r\n\r\n// Corners of the bounding box\r\ntype Corners = {\r\n    minX: number;\r\n    minY: number;\r\n    maxX: number;\r\n    maxY: number;\r\n};\r\n\r\n/**\r\n * Calculates the bounding box for a group shape in a Lottie animation.\r\n * @param rawGroup The raw group shape to calculate the bounding box for\r\n * @returns The bounding box for the group shape\r\n */\r\nexport function GetBoundingBox(rawGroup: RawGroupShape): BoundingBox {\r\n    const boxCorners: Corners = {\r\n        minX: Infinity,\r\n        minY: Infinity,\r\n        maxX: -Infinity,\r\n        maxY: -Infinity,\r\n    };\r\n\r\n    if (rawGroup.it !== undefined) {\r\n        for (let i = 0; i < rawGroup.it.length; i++) {\r\n            if (rawGroup.it[i].ty === \"rc\") {\r\n                GetRectangleVertices(boxCorners, rawGroup.it[i] as RawRectangleShape);\r\n            } else if (rawGroup.it[i].ty === \"sh\") {\r\n                GetPathVertices(boxCorners, rawGroup.it[i] as RawPathShape);\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        width: Math.ceil(boxCorners.maxX - boxCorners.minX),\r\n        height: Math.ceil(boxCorners.maxY - boxCorners.minY),\r\n        centerX: Math.ceil((boxCorners.maxX + boxCorners.minX) / 2),\r\n        centerY: Math.ceil((boxCorners.maxY + boxCorners.minY) / 2),\r\n    };\r\n}\r\n\r\nfunction GetRectangleVertices(boxCorners: Corners, rect: RawRectangleShape): void {\r\n    const size = rect.s.k as number[];\r\n    const position = rect.p.k as number[];\r\n\r\n    // Calculate the four corners of the rectangle\r\n    UpdateBoxCorners(boxCorners, position[0] - size[0] / 2, position[1] - size[1] / 2);\r\n    UpdateBoxCorners(boxCorners, position[0] + size[0] / 2, position[1] - size[1] / 2);\r\n    UpdateBoxCorners(boxCorners, position[0] + size[0] / 2, position[1] + size[1] / 2);\r\n    UpdateBoxCorners(boxCorners, position[0] - size[0] / 2, position[1] + size[1] / 2);\r\n}\r\n\r\nfunction GetPathVertices(boxCorners: Corners, path: RawPathShape): void {\r\n    const bezier = path.ks.k as RawBezier;\r\n    const vertices = bezier.v;\r\n    const inTangents = bezier.i;\r\n    const outTangents = bezier.o;\r\n\r\n    // Check the control points of the path\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        UpdateBoxCorners(boxCorners, vertices[i][0], vertices[i][1]);\r\n    }\r\n\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        // Skip last point if the path is not closed\r\n        if (!bezier.c && i === vertices.length - 1) {\r\n            continue;\r\n        }\r\n\r\n        const start = vertices[i];\r\n        const end = i === vertices.length - 1 ? vertices[0] : vertices[i + 1];\r\n        const outTangent = outTangents[i];\r\n        const inTangent = i === vertices.length - 1 ? inTangents[0] : inTangents[i + 1];\r\n\r\n        // Calculate the points where the tangent is zero\r\n        CalculatePointsWithTangentZero(\r\n            boxCorners,\r\n            start[0],\r\n            start[1],\r\n            end[0],\r\n            end[1],\r\n            start[0] + outTangent[0],\r\n            start[1] + outTangent[1],\r\n            end[0] + inTangent[0],\r\n            end[1] + inTangent[1]\r\n        );\r\n    }\r\n}\r\n\r\nfunction CalculatePointsWithTangentZero(\r\n    boxCorners: Corners,\r\n    startX: number,\r\n    startY: number,\r\n    endX: number,\r\n    endY: number,\r\n    controlPoint1X: number,\r\n    controlPoint1Y: number,\r\n    controlPoint2X: number,\r\n    controlPoint2Y: number\r\n): void {\r\n    // Calculate the derivative of the bezier formula for X and Y components\r\n    // For X component:\r\n    const ax = 3 * (endX - 3 * controlPoint2X + 3 * controlPoint1X - startX);\r\n    const bx = 6 * (controlPoint2X - 2 * controlPoint1X + startX);\r\n    const cx = 3 * (controlPoint1X - startX);\r\n\r\n    // For Y component:\r\n    const ay = 3 * (endY - 3 * controlPoint2Y + 3 * controlPoint1Y - startY);\r\n    const by = 6 * (controlPoint2Y - 2 * controlPoint1Y + startY);\r\n    const cy = 3 * (controlPoint1Y - startY);\r\n\r\n    // Solve the quadratic equation where dt/dt = 0 (tangent is zero)\r\n    const rootsX = SolveQuadratic(ax, bx, cx);\r\n    const rootsY = SolveQuadratic(ay, by, cy);\r\n\r\n    // Merge + dedupe (roots arrays are tiny: <=2 each)\r\n    const candidateTs = rootsX.slice(); // copy\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        const ty = rootsY[i];\r\n        let exists = false;\r\n        for (let j = 0; j < candidateTs.length; j++) {\r\n            if (candidateTs[j] === ty) {\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!exists) {\r\n            candidateTs.push(ty);\r\n        }\r\n    }\r\n\r\n    // Evaluate the bezier at the calculated t values to find the points of the curve where the tangent is zero\r\n    for (let i = 0; i < candidateTs.length; i++) {\r\n        const t = candidateTs[i];\r\n        if (t >= 0 && t <= 1) {\r\n            const x = BezierPoint(t, startX, controlPoint1X, controlPoint2X, endX);\r\n            const y = BezierPoint(t, startY, controlPoint1Y, controlPoint2Y, endY);\r\n            UpdateBoxCorners(boxCorners, x, y);\r\n        }\r\n    }\r\n}\r\n\r\n// Alternative implementation for bounding box calculation using sampling of the bezier curve instead of finding points where the tangent is zero.\r\n// function bezierBoundingBoxSampled(boxCorners: Corners, start:IVector2Like, outTangent:IVector2Like, inTangent:IVector2Like, end:IVector2Like) {\r\n//     for (let i = 0; i <= SamplingSteps; i++) {\r\n//         const t = i / SamplingSteps;\r\n\r\n//         const x = bezierPoint(t, start.x, outTangent.x, inTangent.x, end.x);\r\n//         const y = bezierPoint(t, start.y, outTangent.y, inTangent.y, end.y);\r\n//         updateBoxCorners(boxCorners, x, y);\r\n//     }\r\n// }\r\n\r\nfunction SolveQuadratic(a: number, b: number, c: number): number[] {\r\n    const roots: number[] = [];\r\n\r\n    // Handle the case where a is zero (linear equation)\r\n    // Linear equation: bx + c = 0 => x = -c / b\r\n    if (Math.abs(a) < 1e-10) {\r\n        if (Math.abs(b) > 1e-10) {\r\n            const root = -c / b;\r\n            roots.push(root);\r\n        }\r\n\r\n        return roots;\r\n    }\r\n\r\n    // Solve the quadratic equation ax^2 + bx + c = 0\r\n    const discriminant = b * b - 4 * a * c;\r\n    if (discriminant < 0) {\r\n        return roots; // No real roots\r\n    }\r\n\r\n    if (Math.abs(discriminant) < 1e-10) {\r\n        const root = -b / (2 * a);\r\n        roots.push(root);\r\n    } else {\r\n        const sqrtD = Math.sqrt(discriminant);\r\n        const root1 = (-b + sqrtD) / (2 * a);\r\n        const root2 = (-b - sqrtD) / (2 * a);\r\n        roots.push(root1);\r\n        roots.push(root2);\r\n    }\r\n\r\n    return roots;\r\n}\r\n\r\nfunction BezierPoint(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n    const mt = 1 - t;\r\n    return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;\r\n}\r\n\r\nfunction UpdateBoxCorners(boxCorners: Corners, x: number, y: number): void {\r\n    if (x < boxCorners.minX) {\r\n        boxCorners.minX = x;\r\n    }\r\n    if (x > boxCorners.maxX) {\r\n        boxCorners.maxX = x;\r\n    }\r\n    if (y < boxCorners.minY) {\r\n        boxCorners.minY = y;\r\n    }\r\n    if (y > boxCorners.maxY) {\r\n        boxCorners.maxY = y;\r\n    }\r\n}\r\n"]}